//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: _java/com/kloudtek/util/Base64.java
//
//  Created by yinkaf on 6/14/14.
//

#include "Base64.h"
#include "BaseNCodec.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "StringUtils.h"
#include "java/lang/Deprecated.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/System.h"
#include "java/math/BigInteger.h"

BOOL KTUtilBase64_initialized = NO;

@implementation KTUtilBase64

IOSByteArray * KTUtilBase64_CHUNK_SEPARATOR_;
IOSByteArray * KTUtilBase64_STANDARD_ENCODE_TABLE_;
IOSByteArray * KTUtilBase64_URL_SAFE_ENCODE_TABLE_;
IOSByteArray * KTUtilBase64_DECODE_TABLE_;

- (id)init {
  return [self initKTUtilBase64WithInt:0];
}

- (id)initWithBoolean:(BOOL)urlSafe {
  return [self initKTUtilBase64WithInt:KTUtilBaseNCodec_MIME_CHUNK_SIZE withByteArray:KTUtilBase64_CHUNK_SEPARATOR_ withBoolean:urlSafe];
}

- (id)initKTUtilBase64WithInt:(int)lineLength {
  return [self initKTUtilBase64WithInt:lineLength withByteArray:KTUtilBase64_CHUNK_SEPARATOR_];
}

- (id)initWithInt:(int)lineLength {
  return [self initKTUtilBase64WithInt:lineLength];
}

- (id)initKTUtilBase64WithInt:(int)lineLength
                withByteArray:(IOSByteArray *)lineSeparator {
  return [self initKTUtilBase64WithInt:lineLength withByteArray:lineSeparator withBoolean:NO];
}

- (id)initWithInt:(int)lineLength
    withByteArray:(IOSByteArray *)lineSeparator {
  return [self initKTUtilBase64WithInt:lineLength withByteArray:lineSeparator];
}

- (id)initKTUtilBase64WithInt:(int)lineLength
                withByteArray:(IOSByteArray *)lineSeparator
                  withBoolean:(BOOL)urlSafe {
  if (self = [super initWithInt:KTUtilBase64_BYTES_PER_UNENCODED_BLOCK withInt:KTUtilBase64_BYTES_PER_ENCODED_BLOCK withInt:lineLength withInt:lineSeparator == nil ? 0 : (int) [lineSeparator count]]) {
    decodeTable_ = KTUtilBase64_DECODE_TABLE_;
    if (lineSeparator != nil) {
      if ([self containsAlphabetOrPadWithByteArray:lineSeparator]) {
        NSString *sep = [KTUtilStringUtils utf8WithByteArray:lineSeparator];
        @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"lineSeparator must not contain base64 characters: [%@]", sep]];
      }
      if (lineLength > 0) {
        self->encodeSize_ = KTUtilBase64_BYTES_PER_ENCODED_BLOCK + (int) [lineSeparator count];
        self->lineSeparator_ = [IOSByteArray arrayWithLength:(int) [lineSeparator count]];
        [JavaLangSystem arraycopyWithId:lineSeparator withInt:0 withId:self->lineSeparator_ withInt:0 withInt:(int) [lineSeparator count]];
      }
      else {
        self->encodeSize_ = KTUtilBase64_BYTES_PER_ENCODED_BLOCK;
        self->lineSeparator_ = nil;
      }
    }
    else {
      self->encodeSize_ = KTUtilBase64_BYTES_PER_ENCODED_BLOCK;
      self->lineSeparator_ = nil;
    }
    self->decodeSize_ = self->encodeSize_ - 1;
    self->encodeTable_ = urlSafe ? KTUtilBase64_URL_SAFE_ENCODE_TABLE_ : KTUtilBase64_STANDARD_ENCODE_TABLE_;
  }
  return self;
}

- (id)initWithInt:(int)lineLength
    withByteArray:(IOSByteArray *)lineSeparator
      withBoolean:(BOOL)urlSafe {
  return [self initKTUtilBase64WithInt:lineLength withByteArray:lineSeparator withBoolean:urlSafe];
}

- (BOOL)isUrlSafe {
  return self->encodeTable_ == KTUtilBase64_URL_SAFE_ENCODE_TABLE_;
}

- (void)encodeWithByteArray:(IOSByteArray *)inArg
                    withInt:(int)inPos
                    withInt:(int)inAvail
withKTUtilBaseNCodec_Context:(KTUtilBaseNCodec_Context *)context {
  if (((KTUtilBaseNCodec_Context *) nil_chk(context))->eof_) {
    return;
  }
  if (inAvail < 0) {
    context->eof_ = YES;
    if (0 == context->modulus_ && lineLength_ == 0) {
      return;
    }
    IOSByteArray *buffer = [self ensureBufferSizeWithInt:encodeSize_ withKTUtilBaseNCodec_Context:context];
    int savedPos = context->pos_;
    switch (context->modulus_) {
      case 0:
      break;
      case 1:
      (*IOSByteArray_GetRef(nil_chk(buffer), context->pos_++)) = IOSByteArray_Get(nil_chk(encodeTable_), (context->ibitWorkArea_ >> 2) & KTUtilBase64_MASK_6BITS);
      (*IOSByteArray_GetRef(buffer, context->pos_++)) = IOSByteArray_Get(encodeTable_, (context->ibitWorkArea_ << 4) & KTUtilBase64_MASK_6BITS);
      if (encodeTable_ == KTUtilBase64_STANDARD_ENCODE_TABLE_) {
        (*IOSByteArray_GetRef(buffer, context->pos_++)) = PAD_;
        (*IOSByteArray_GetRef(buffer, context->pos_++)) = PAD_;
      }
      break;
      case 2:
      (*IOSByteArray_GetRef(nil_chk(buffer), context->pos_++)) = IOSByteArray_Get(nil_chk(encodeTable_), (context->ibitWorkArea_ >> 10) & KTUtilBase64_MASK_6BITS);
      (*IOSByteArray_GetRef(buffer, context->pos_++)) = IOSByteArray_Get(encodeTable_, (context->ibitWorkArea_ >> 4) & KTUtilBase64_MASK_6BITS);
      (*IOSByteArray_GetRef(buffer, context->pos_++)) = IOSByteArray_Get(encodeTable_, (context->ibitWorkArea_ << 2) & KTUtilBase64_MASK_6BITS);
      if (encodeTable_ == KTUtilBase64_STANDARD_ENCODE_TABLE_) {
        (*IOSByteArray_GetRef(buffer, context->pos_++)) = PAD_;
      }
      break;
      default:
      @throw [[JavaLangIllegalStateException alloc] initWithNSString:[NSString stringWithFormat:@"Impossible modulus %d", context->modulus_]];
    }
    context->currentLinePos_ += context->pos_ - savedPos;
    if (lineLength_ > 0 && context->currentLinePos_ > 0) {
      [JavaLangSystem arraycopyWithId:lineSeparator_ withInt:0 withId:buffer withInt:context->pos_ withInt:(int) [((IOSByteArray *) nil_chk(lineSeparator_)) count]];
      context->pos_ += (int) [lineSeparator_ count];
    }
  }
  else {
    for (int i = 0; i < inAvail; i++) {
      IOSByteArray *buffer = [self ensureBufferSizeWithInt:encodeSize_ withKTUtilBaseNCodec_Context:context];
      context->modulus_ = (context->modulus_ + 1) % KTUtilBase64_BYTES_PER_UNENCODED_BLOCK;
      int b = IOSByteArray_Get(nil_chk(inArg), inPos++);
      if (b < 0) {
        b += 256;
      }
      context->ibitWorkArea_ = (context->ibitWorkArea_ << 8) + b;
      if (0 == context->modulus_) {
        (*IOSByteArray_GetRef(nil_chk(buffer), context->pos_++)) = IOSByteArray_Get(nil_chk(encodeTable_), (context->ibitWorkArea_ >> 18) & KTUtilBase64_MASK_6BITS);
        (*IOSByteArray_GetRef(buffer, context->pos_++)) = IOSByteArray_Get(encodeTable_, (context->ibitWorkArea_ >> 12) & KTUtilBase64_MASK_6BITS);
        (*IOSByteArray_GetRef(buffer, context->pos_++)) = IOSByteArray_Get(encodeTable_, (context->ibitWorkArea_ >> 6) & KTUtilBase64_MASK_6BITS);
        (*IOSByteArray_GetRef(buffer, context->pos_++)) = IOSByteArray_Get(encodeTable_, context->ibitWorkArea_ & KTUtilBase64_MASK_6BITS);
        context->currentLinePos_ += KTUtilBase64_BYTES_PER_ENCODED_BLOCK;
        if (lineLength_ > 0 && lineLength_ <= context->currentLinePos_) {
          [JavaLangSystem arraycopyWithId:lineSeparator_ withInt:0 withId:buffer withInt:context->pos_ withInt:(int) [((IOSByteArray *) nil_chk(lineSeparator_)) count]];
          context->pos_ += (int) [lineSeparator_ count];
          context->currentLinePos_ = 0;
        }
      }
    }
  }
}

- (void)decodeWithByteArray:(IOSByteArray *)inArg
                    withInt:(int)inPos
                    withInt:(int)inAvail
withKTUtilBaseNCodec_Context:(KTUtilBaseNCodec_Context *)context {
  if (((KTUtilBaseNCodec_Context *) nil_chk(context))->eof_) {
    return;
  }
  if (inAvail < 0) {
    context->eof_ = YES;
  }
  for (int i = 0; i < inAvail; i++) {
    IOSByteArray *buffer = [self ensureBufferSizeWithInt:decodeSize_ withKTUtilBaseNCodec_Context:context];
    char b = IOSByteArray_Get(nil_chk(inArg), inPos++);
    if (b == PAD_) {
      context->eof_ = YES;
      break;
    }
    else {
      if (b >= 0 && b < (int) [((IOSByteArray *) nil_chk(KTUtilBase64_DECODE_TABLE_)) count]) {
        int result = IOSByteArray_Get(KTUtilBase64_DECODE_TABLE_, b);
        if (result >= 0) {
          context->modulus_ = (context->modulus_ + 1) % KTUtilBase64_BYTES_PER_ENCODED_BLOCK;
          context->ibitWorkArea_ = (context->ibitWorkArea_ << KTUtilBase64_BITS_PER_ENCODED_BYTE) + result;
          if (context->modulus_ == 0) {
            (*IOSByteArray_GetRef(nil_chk(buffer), context->pos_++)) = (char) ((context->ibitWorkArea_ >> 16) & KTUtilBaseNCodec_MASK_8BITS);
            (*IOSByteArray_GetRef(buffer, context->pos_++)) = (char) ((context->ibitWorkArea_ >> 8) & KTUtilBaseNCodec_MASK_8BITS);
            (*IOSByteArray_GetRef(buffer, context->pos_++)) = (char) (context->ibitWorkArea_ & KTUtilBaseNCodec_MASK_8BITS);
          }
        }
      }
    }
  }
  if (context->eof_ && context->modulus_ != 0) {
    IOSByteArray *buffer = [self ensureBufferSizeWithInt:decodeSize_ withKTUtilBaseNCodec_Context:context];
    switch (context->modulus_) {
      case 1:
      break;
      case 2:
      context->ibitWorkArea_ = context->ibitWorkArea_ >> 4;
      (*IOSByteArray_GetRef(nil_chk(buffer), context->pos_++)) = (char) ((context->ibitWorkArea_) & KTUtilBaseNCodec_MASK_8BITS);
      break;
      case 3:
      context->ibitWorkArea_ = context->ibitWorkArea_ >> 2;
      (*IOSByteArray_GetRef(nil_chk(buffer), context->pos_++)) = (char) ((context->ibitWorkArea_ >> 8) & KTUtilBaseNCodec_MASK_8BITS);
      (*IOSByteArray_GetRef(buffer, context->pos_++)) = (char) ((context->ibitWorkArea_) & KTUtilBaseNCodec_MASK_8BITS);
      break;
      default:
      @throw [[JavaLangIllegalStateException alloc] initWithNSString:[NSString stringWithFormat:@"Impossible modulus %d", context->modulus_]];
    }
  }
}

+ (BOOL)isArrayByteBase64WithByteArray:(IOSByteArray *)arrayOctet {
  return [KTUtilBase64 isBase64WithByteArray:arrayOctet];
}

+ (BOOL)isBase64WithByte:(char)octet {
  return octet == KTUtilBaseNCodec_PAD_DEFAULT || (octet >= 0 && octet < (int) [((IOSByteArray *) nil_chk(KTUtilBase64_DECODE_TABLE_)) count] && IOSByteArray_Get(KTUtilBase64_DECODE_TABLE_, octet) != -1);
}

+ (BOOL)isBase64WithNSString:(NSString *)base64 {
  return [KTUtilBase64 isBase64WithByteArray:[KTUtilStringUtils utf8WithNSString:base64]];
}

+ (BOOL)isBase64WithByteArray:(IOSByteArray *)arrayOctet {
  for (int i = 0; i < (int) [((IOSByteArray *) nil_chk(arrayOctet)) count]; i++) {
    if (![KTUtilBase64 isBase64WithByte:IOSByteArray_Get(arrayOctet, i)] && ![KTUtilBaseNCodec isWhiteSpaceWithByte:IOSByteArray_Get(arrayOctet, i)]) {
      return NO;
    }
  }
  return YES;
}

+ (IOSByteArray *)encodeBase64WithByteArray:(IOSByteArray *)binaryData {
  return [KTUtilBase64 encodeBase64WithByteArray:binaryData withBoolean:NO];
}

+ (NSString *)encodeBase64StringWithByteArray:(IOSByteArray *)binaryData {
  return [KTUtilStringUtils utf8WithByteArray:[KTUtilBase64 encodeBase64WithByteArray:binaryData withBoolean:NO]];
}

+ (IOSByteArray *)encodeBase64URLSafeWithByteArray:(IOSByteArray *)binaryData {
  return [KTUtilBase64 encodeBase64WithByteArray:binaryData withBoolean:NO withBoolean:YES];
}

+ (NSString *)encodeBase64URLSafeStringWithByteArray:(IOSByteArray *)binaryData {
  return [KTUtilStringUtils utf8WithByteArray:[KTUtilBase64 encodeBase64WithByteArray:binaryData withBoolean:NO withBoolean:YES]];
}

+ (IOSByteArray *)encodeBase64ChunkedWithByteArray:(IOSByteArray *)binaryData {
  return [KTUtilBase64 encodeBase64WithByteArray:binaryData withBoolean:YES];
}

+ (IOSByteArray *)encodeBase64WithByteArray:(IOSByteArray *)binaryData
                                withBoolean:(BOOL)isChunked {
  return [KTUtilBase64 encodeBase64WithByteArray:binaryData withBoolean:isChunked withBoolean:NO];
}

+ (IOSByteArray *)encodeBase64WithByteArray:(IOSByteArray *)binaryData
                                withBoolean:(BOOL)isChunked
                                withBoolean:(BOOL)urlSafe {
  return [KTUtilBase64 encodeBase64WithByteArray:binaryData withBoolean:isChunked withBoolean:urlSafe withInt:JavaLangInteger_MAX_VALUE];
}

+ (IOSByteArray *)encodeBase64WithByteArray:(IOSByteArray *)binaryData
                                withBoolean:(BOOL)isChunked
                                withBoolean:(BOOL)urlSafe
                                    withInt:(int)maxResultSize {
  if (binaryData == nil || (int) [binaryData count] == 0) {
    return binaryData;
  }
  KTUtilBase64 *b64 = isChunked ? [[KTUtilBase64 alloc] initWithBoolean:urlSafe] : [[KTUtilBase64 alloc] initWithInt:0 withByteArray:KTUtilBase64_CHUNK_SEPARATOR_ withBoolean:urlSafe];
  long long int len = [b64 getEncodedLengthWithByteArray:binaryData];
  if (len > maxResultSize) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Input array too big, the output array would be bigger (%lld) than the specified maximum size of %d", len, maxResultSize]];
  }
  return [b64 encodeWithByteArray:binaryData];
}

+ (IOSByteArray *)decodeBase64WithNSString:(NSString *)base64String {
  return [((KTUtilBase64 *) [[KTUtilBase64 alloc] init]) decodeWithNSString:base64String];
}

+ (IOSByteArray *)decodeBase64WithByteArray:(IOSByteArray *)base64Data {
  return [((KTUtilBase64 *) [[KTUtilBase64 alloc] init]) decodeWithByteArray:base64Data];
}

+ (JavaMathBigInteger *)decodeIntegerWithByteArray:(IOSByteArray *)pArray {
  return [[JavaMathBigInteger alloc] initWithInt:1 withByteArray:[KTUtilBase64 decodeBase64WithByteArray:pArray]];
}

+ (IOSByteArray *)encodeIntegerWithJavaMathBigInteger:(JavaMathBigInteger *)bigInt {
  if (bigInt == nil) {
    @throw [[JavaLangNullPointerException alloc] initWithNSString:@"encodeInteger called with null parameter"];
  }
  return [KTUtilBase64 encodeBase64WithByteArray:[KTUtilBase64 toIntegerBytesWithJavaMathBigInteger:bigInt] withBoolean:NO];
}

+ (IOSByteArray *)toIntegerBytesWithJavaMathBigInteger:(JavaMathBigInteger *)bigInt {
  int bitlen = [((JavaMathBigInteger *) nil_chk(bigInt)) bitLength];
  bitlen = ((bitlen + 7) >> 3) << 3;
  IOSByteArray *bigBytes = [bigInt toByteArray];
  if ((([bigInt bitLength] % 8) != 0) && ((([bigInt bitLength] / 8) + 1) == (bitlen / 8))) {
    return bigBytes;
  }
  int startSrc = 0;
  int len = (int) [((IOSByteArray *) nil_chk(bigBytes)) count];
  if (([bigInt bitLength] % 8) == 0) {
    startSrc = 1;
    len--;
  }
  int startDst = bitlen / 8 - len;
  IOSByteArray *resizedBytes = [IOSByteArray arrayWithLength:bitlen / 8];
  [JavaLangSystem arraycopyWithId:bigBytes withInt:startSrc withId:resizedBytes withInt:startDst withInt:len];
  return resizedBytes;
}

- (BOOL)isInAlphabetWithByte:(char)octet {
  return octet >= 0 && octet < (int) [((IOSByteArray *) nil_chk(decodeTable_)) count] && IOSByteArray_Get(decodeTable_, octet) != -1;
}

+ (void)initialize {
  if (self == [KTUtilBase64 class]) {
    KTUtilBase64_CHUNK_SEPARATOR_ = [IOSByteArray arrayWithBytes:(char[]){ 0x000d, 0x000a } count:2];
    KTUtilBase64_STANDARD_ENCODE_TABLE_ = [IOSByteArray arrayWithBytes:(char[]){ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' } count:64];
    KTUtilBase64_URL_SAFE_ENCODE_TABLE_ = [IOSByteArray arrayWithBytes:(char[]){ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_' } count:64];
    KTUtilBase64_DECODE_TABLE_ = [IOSByteArray arrayWithBytes:(char[]){ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 } count:123];
    KTUtilBase64_initialized = YES;
  }
}

- (void)copyAllFieldsTo:(KTUtilBase64 *)other {
  [super copyAllFieldsTo:other];
  other->decodeSize_ = decodeSize_;
  other->decodeTable_ = decodeTable_;
  other->encodeSize_ = encodeSize_;
  other->encodeTable_ = encodeTable_;
  other->lineSeparator_ = lineSeparator_;
}
+ (IOSObjectArray *)__annotations_isArrayByteBase64WithByteArray_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [[JavaLangDeprecated alloc] init] } count:1 type:[IOSClass classWithProtocol:@protocol(JavaLangAnnotationAnnotation)]];
}


+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "init", "Base64", NULL, 0x1, NULL },
    { "initWithBoolean:", "Base64", NULL, 0x1, NULL },
    { "initWithInt:", "Base64", NULL, 0x1, NULL },
    { "initWithInt:withByteArray:", "Base64", NULL, 0x1, NULL },
    { "initWithInt:withByteArray:withBoolean:", "Base64", NULL, 0x1, NULL },
    { "isUrlSafe", NULL, "Z", 0x1, NULL },
    { "encodeWithByteArray:withInt:withInt:withKTUtilBaseNCodec_Context:", "encode", "V", 0x0, NULL },
    { "decodeWithByteArray:withInt:withInt:withKTUtilBaseNCodec_Context:", "decode", "V", 0x0, NULL },
    { "isArrayByteBase64WithByteArray:", "isArrayByteBase64", "Z", 0x9, NULL },
    { "isBase64WithByte:", "isBase64", "Z", 0x9, NULL },
    { "isBase64WithNSString:", "isBase64", "Z", 0x9, NULL },
    { "isBase64WithByteArray:", "isBase64", "Z", 0x9, NULL },
    { "encodeBase64WithByteArray:", "encodeBase64", "[B", 0x9, NULL },
    { "encodeBase64StringWithByteArray:", "encodeBase64String", "Ljava.lang.String;", 0x9, NULL },
    { "encodeBase64URLSafeWithByteArray:", "encodeBase64URLSafe", "[B", 0x9, NULL },
    { "encodeBase64URLSafeStringWithByteArray:", "encodeBase64URLSafeString", "Ljava.lang.String;", 0x9, NULL },
    { "encodeBase64ChunkedWithByteArray:", "encodeBase64Chunked", "[B", 0x9, NULL },
    { "encodeBase64WithByteArray:withBoolean:", "encodeBase64", "[B", 0x9, NULL },
    { "encodeBase64WithByteArray:withBoolean:withBoolean:", "encodeBase64", "[B", 0x9, NULL },
    { "encodeBase64WithByteArray:withBoolean:withBoolean:withInt:", "encodeBase64", "[B", 0x9, NULL },
    { "decodeBase64WithNSString:", "decodeBase64", "[B", 0x9, NULL },
    { "decodeBase64WithByteArray:", "decodeBase64", "[B", 0x9, NULL },
    { "decodeIntegerWithByteArray:", "decodeInteger", "Ljava.math.BigInteger;", 0x9, NULL },
    { "encodeIntegerWithJavaMathBigInteger:", "encodeInteger", "[B", 0x9, NULL },
    { "toIntegerBytesWithJavaMathBigInteger:", "toIntegerBytes", "[B", 0x8, NULL },
    { "isInAlphabetWithByte:", "isInAlphabet", "Z", 0x4, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "BITS_PER_ENCODED_BYTE_", NULL, 0x1a, "I", NULL, .constantValue.asInt = KTUtilBase64_BITS_PER_ENCODED_BYTE },
    { "BYTES_PER_UNENCODED_BLOCK_", NULL, 0x1a, "I", NULL, .constantValue.asInt = KTUtilBase64_BYTES_PER_UNENCODED_BLOCK },
    { "BYTES_PER_ENCODED_BLOCK_", NULL, 0x1a, "I", NULL, .constantValue.asInt = KTUtilBase64_BYTES_PER_ENCODED_BLOCK },
    { "CHUNK_SEPARATOR_", NULL, 0x18, "[B", &KTUtilBase64_CHUNK_SEPARATOR_,  },
    { "STANDARD_ENCODE_TABLE_", NULL, 0x1a, "[B", &KTUtilBase64_STANDARD_ENCODE_TABLE_,  },
    { "URL_SAFE_ENCODE_TABLE_", NULL, 0x1a, "[B", &KTUtilBase64_URL_SAFE_ENCODE_TABLE_,  },
    { "DECODE_TABLE_", NULL, 0x1a, "[B", &KTUtilBase64_DECODE_TABLE_,  },
    { "MASK_6BITS_", NULL, 0x1a, "I", NULL, .constantValue.asInt = KTUtilBase64_MASK_6BITS },
    { "encodeTable_", NULL, 0x12, "[B", NULL,  },
    { "decodeTable_", NULL, 0x12, "[B", NULL,  },
    { "lineSeparator_", NULL, 0x12, "[B", NULL,  },
    { "decodeSize_", NULL, 0x12, "I", NULL,  },
    { "encodeSize_", NULL, 0x12, "I", NULL,  },
  };
  static J2ObjcClassInfo _KTUtilBase64 = { "Base64", "com.kloudtek.util", NULL, 0x1, 26, methods, 13, fields, 0, NULL};
  return &_KTUtilBase64;
}

@end
