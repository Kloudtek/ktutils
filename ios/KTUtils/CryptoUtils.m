//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: _java/com/kloudtek/util/crypto/CryptoUtils.java
//
//  Created by yinkaf on 6/11/14.
//

#include "CryptoUtils.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/nio/ByteBuffer.h"
#include "java/nio/CharBuffer.h"
#include "Key.h"
#include "java/security/SecureRandom.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collection.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/logging/Level.h"
#include "java/util/logging/Logger.h"
#include "DestroyFailedException.h"
#include "Destroyable.h"

BOOL ComKloudtekUtilCryptoCryptoUtils_initialized = NO;

@implementation ComKloudtekUtilCryptoCryptoUtils

JavaUtilLoggingLogger * ComKloudtekUtilCryptoCryptoUtils_logger_;
JavaSecuritySecureRandom * ComKloudtekUtilCryptoCryptoUtils_rng__;

+ (IOSObjectArray *)splitKeyWithByteArray:(IOSByteArray *)key
                                  withInt:(int)amount {
  int keyLen = (int) [((IOSByteArray *) nil_chk(key)) count];
  JavaUtilArrayList *keys = [[JavaUtilArrayList alloc] initWithInt:amount];
  if (amount < 0) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Amount must be 1 or more"];
  }
  else if (amount == 1) {
    [keys addWithId:key];
  }
  else {
    JavaSecuritySecureRandom *rng = [[JavaSecuritySecureRandom alloc] init];
    IOSByteArray *xorVal = key;
    for (int i = 0; i < amount - 1; i++) {
      IOSByteArray *newKey = [IOSByteArray arrayWithLength:keyLen];
      [rng nextBytesWithByteArray:newKey];
      [keys addWithId:newKey];
      xorVal = [ComKloudtekUtilCryptoCryptoUtils xor__WithByteArray:xorVal withByteArray:newKey];
    }
    [keys addWithId:xorVal];
  }
  return [keys toArrayWithNSObjectArray:[IOSByteArray arrayWithDimensions:2 lengths:(int[]){ (int) [key count], amount }]];
}

+ (void)zeroWithCharArray2:(IOSObjectArray *)data {
  {
    IOSObjectArray *a__ = data;
    IOSCharArray * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    IOSCharArray * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      IOSCharArray *chars = (*b__++);
      if (chars != nil) {
        [JavaUtilArrays fillWithCharArray:chars withChar:0x0000];
      }
    }
  }
}

+ (void)zeroWithByteArray2:(IOSObjectArray *)data {
  {
    IOSObjectArray *a__ = data;
    IOSByteArray * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    IOSByteArray * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      IOSByteArray *bytes = (*b__++);
      if (bytes != nil) {
        [JavaUtilArrays fillWithByteArray:bytes withByte:(char) 0];
      }
    }
  }
}

+ (void)zeroWithJavaNioCharBuffer:(JavaNioCharBuffer *)data {
  [ComKloudtekUtilCryptoCryptoUtils zeroWithCharArray2:[IOSObjectArray arrayWithObjects:(id[]){ [((JavaNioCharBuffer *) nil_chk(data)) array] } count:1 type:[IOSCharArray iosClass]]];
}

+ (void)zeroWithJavaNioByteBuffer:(JavaNioByteBuffer *)data {
  [ComKloudtekUtilCryptoCryptoUtils zeroWithByteArray2:[IOSObjectArray arrayWithObjects:(id[]){ [((JavaNioByteBuffer *) nil_chk(data)) array] } count:1 type:[IOSByteArray iosClass]]];
}

+ (IOSByteArray *)mergeSplitKeyWithByteArray2:(IOSObjectArray *)keys {
  if (keys == nil) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"There must be at least one key"];
  }
  else {
    return [ComKloudtekUtilCryptoCryptoUtils mergeSplitKeyWithJavaUtilCollection:[JavaUtilArrays asListWithNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ keys } count:1 type:[IOSClass classWithClass:[NSObject class]]]]];
  }
}

+ (IOSByteArray *)mergeSplitKeyWithJavaUtilCollection:(id<JavaUtilCollection>)keys {
  if (keys == nil || [keys isEmpty]) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"There must be at least one key"];
  }
  else if ([keys size] == 1) {
    return [((id<JavaUtilIterator>) nil_chk([keys iterator])) next];
  }
  else {
    id<JavaUtilIterator> i = [keys iterator];
    IOSByteArray *val = [((id<JavaUtilIterator>) nil_chk(i)) next];
    int len = (int) [((IOSByteArray *) nil_chk(val)) count];
    while ([i hasNext]) {
      IOSByteArray *next = [i next];
      if ((int) [((IOSByteArray *) nil_chk(next)) count] != len) {
        @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"All keys must have the same length"];
      }
      val = [ComKloudtekUtilCryptoCryptoUtils xor__WithByteArray:val withByteArray:next];
    }
    return val;
  }
}

+ (IOSByteArray *)xor__WithByteArray:(IOSByteArray *)b1
                       withByteArray:(IOSByteArray *)b2 {
  IOSByteArray *val = [IOSByteArray arrayWithLength:(int) [((IOSByteArray *) nil_chk(b1)) count]];
  for (int i = 0; i < (int) [b1 count]; i++) {
    (*IOSByteArray_GetRef(val, i)) = (char) (IOSByteArray_Get(b1, i) ^ IOSByteArray_Get(nil_chk(b2), i));
  }
  return val;
}

+ (JavaSecuritySecureRandom *)rng {
  return ComKloudtekUtilCryptoCryptoUtils_rng__;
}

+ (void)destroyWithJavaSecurityKey:(id<JavaSecurityKey>)key {
  if (key != nil && [(id) key conformsToProtocol: @protocol(JavaxSecurityAuthDestroyable)]) {
    if (![((id<JavaxSecurityAuthDestroyable>) check_protocol_cast(key, @protocol(JavaxSecurityAuthDestroyable))) isDestroyed]) {
      @try {
        [((id<JavaxSecurityAuthDestroyable>) check_protocol_cast(key, @protocol(JavaxSecurityAuthDestroyable))) destroy];
      }
      @catch (JavaxSecurityAuthDestroyFailedException *e) {
        [((JavaUtilLoggingLogger *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_logger_)) logWithJavaUtilLoggingLevel:JavaUtilLoggingLevel_get_WARNING_() withNSString:[NSString stringWithFormat:@"Failed to destroy key: %@", [((JavaxSecurityAuthDestroyFailedException *) nil_chk(e)) getMessage]] withJavaLangThrowable:e];
      }
    }
  }
}

- (id)init {
  return [super init];
}

+ (void)initialize {
  if (self == [ComKloudtekUtilCryptoCryptoUtils class]) {
    ComKloudtekUtilCryptoCryptoUtils_logger_ = [JavaUtilLoggingLogger getLoggerWithNSString:[[IOSClass classWithClass:[ComKloudtekUtilCryptoCryptoUtils class]] getName]];
    ComKloudtekUtilCryptoCryptoUtils_rng__ = [[JavaSecuritySecureRandom alloc] init];
    ComKloudtekUtilCryptoCryptoUtils_initialized = YES;
  }
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "splitKeyWithByteArray:withInt:", "splitKey", "[[B", 0x9, NULL },
    { "zeroWithCharArray2:", "zero", "V", 0x89, NULL },
    { "zeroWithByteArray2:", "zero", "V", 0x89, NULL },
    { "zeroWithJavaNioCharBuffer:", "zero", "V", 0x9, NULL },
    { "zeroWithJavaNioByteBuffer:", "zero", "V", 0x9, NULL },
    { "mergeSplitKeyWithByteArray2:", "mergeSplitKey", "[B", 0x89, NULL },
    { "mergeSplitKeyWithJavaUtilCollection:", "mergeSplitKey", "[B", 0x9, NULL },
    { "xor__WithByteArray:withByteArray:", "xor", "[B", 0xa, NULL },
    { "rng", NULL, "Ljava.security.SecureRandom;", 0x9, NULL },
    { "destroyWithJavaSecurityKey:", "destroy", "V", 0x9, NULL },
    { "init", NULL, NULL, 0x1, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "logger_", NULL, 0x1a, "Ljava.util.logging.Logger;", &ComKloudtekUtilCryptoCryptoUtils_logger_,  },
    { "rng__", "rng", 0x1a, "Ljava.security.SecureRandom;", &ComKloudtekUtilCryptoCryptoUtils_rng__,  },
  };
  static J2ObjcClassInfo _ComKloudtekUtilCryptoCryptoUtils = { "CryptoUtils", "com.kloudtek.util.crypto", NULL, 0x1, 11, methods, 2, fields, 0, NULL};
  return &_ComKloudtekUtilCryptoCryptoUtils;
}

@end
