//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: _java/com/kloudtek/util/crypto/CryptoUtils.java
//
//  Created by yinkaf on 6/14/14.
//

#include "AsymmetricAlgorithm.h"
#include "CryptoEngine.h"
#include "CryptoUtils.h"
#include "DigestAlgorithm.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "SymmetricAlgorithm.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/StringBuilder.h"
#include "java/nio/ByteBuffer.h"
#include "java/nio/CharBuffer.h"
#include "InvalidKeyException.h"
#include "Key.h"
#include "KeyPair.h"
#include "PrivateKey.h"
#include "PublicKey.h"
#include "java/security/SecureRandom.h"
#include "SignatureException.h"
#include "RSAPublicKey.h"
#include "InvalidKeySpecException.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collection.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/logging/Level.h"
#include "java/util/logging/Logger.h"
#include "BadPaddingException.h"
#include "IllegalBlockSizeException.h"
#include "SecretKey.h"
#include "DestroyFailedException.h"
#include "Destroyable.h"
#import "TestCryptoEngine.h"

BOOL ComKloudtekUtilCryptoCryptoUtils_initialized = NO;

@implementation ComKloudtekUtilCryptoCryptoUtils

IOSCharArray * ComKloudtekUtilCryptoCryptoUtils_symbolsAllCaps_;
IOSCharArray * ComKloudtekUtilCryptoCryptoUtils_symbols_;
JavaUtilLoggingLogger * ComKloudtekUtilCryptoCryptoUtils_logger_;
ComKloudtekUtilCryptoCryptoEngine * ComKloudtekUtilCryptoCryptoUtils_provider_;
JavaSecuritySecureRandom * ComKloudtekUtilCryptoCryptoUtils_rng__;

+ (id<JavaxCryptoSecretKey>)generateKeyWithComKloudtekUtilCryptoSymmetricAlgorithmEnum:(ComKloudtekUtilCryptoSymmetricAlgorithmEnum *)alg
                                                                               withInt:(int)keysize {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) generateKeyWithComKloudtekUtilCryptoSymmetricAlgorithmEnum:alg withInt:keysize];
}

+ (JavaSecurityKeyPair *)generateRSA4096KeyPair {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) generateRSA4096KeyPair];
}

+ (JavaSecurityKeyPair *)generateRSA2048KeyPair {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) generateRSA2048KeyPair];
}

+ (id<JavaxCryptoSecretKey>)generateHmacKeyWithComKloudtekUtilCryptoDigestAlgorithmEnum:(ComKloudtekUtilCryptoDigestAlgorithmEnum *)algorithm {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) generateHmacKeyWithComKloudtekUtilCryptoDigestAlgorithmEnum:algorithm];
}

+ (id<JavaxCryptoSecretKey>)generatePBEAESKeyWithCharArray:(IOSCharArray *)key
                                                   withInt:(int)iterations
                                             withByteArray:(IOSByteArray *)salt
                                                   withInt:(int)keyLen {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) generatePBEAESKeyWithCharArray:key withInt:iterations withByteArray:salt withInt:keyLen];
}

+ (id<JavaSecurityInterfacesRSAPublicKey>)readRSAPublicKeyWithByteArray:(IOSByteArray *)key {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) readRSAPublicKeyWithByteArray:key];
}

+ (id<JavaSecurityPrivateKey>)readRSAPrivateKeyWithByteArray:(IOSByteArray *)encodedPriKey {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) readRSAPrivateKeyWithByteArray:encodedPriKey];
}

+ (id<JavaxCryptoSecretKey>)readAESKeyWithByteArray:(IOSByteArray *)encodedAesKey {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) readAESKeyWithByteArray:encodedAesKey];
}

+ (id<JavaxCryptoSecretKey>)readHMACKeyWithComKloudtekUtilCryptoDigestAlgorithmEnum:(ComKloudtekUtilCryptoDigestAlgorithmEnum *)algorithm
                                                                      withByteArray:(IOSByteArray *)encodedKey {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) readHMACKeyWithComKloudtekUtilCryptoDigestAlgorithmEnum:algorithm withByteArray:encodedKey];
}

+ (IOSByteArray *)aesDecryptWithJavaxCryptoSecretKey:(id<JavaxCryptoSecretKey>)key
                                       withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) aesDecryptWithJavaxCryptoSecretKey:key withByteArray:data];
}

+ (IOSByteArray *)rsaEncryptWithJavaSecurityPublicKey:(id<JavaSecurityPublicKey>)key
                                        withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) rsaEncryptWithJavaSecurityPublicKey:key withByteArray:data];
}

+ (void)rsaVerifySignatureWithComKloudtekUtilCryptoDigestAlgorithmEnum:(ComKloudtekUtilCryptoDigestAlgorithmEnum *)digestAlgorithms
                                             withJavaSecurityPublicKey:(id<JavaSecurityPublicKey>)key
                                                         withByteArray:(IOSByteArray *)data
                                                         withByteArray:(IOSByteArray *)signature {
  [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) rsaVerifySignatureWithComKloudtekUtilCryptoDigestAlgorithmEnum:digestAlgorithms withJavaSecurityPublicKey:key withByteArray:data withByteArray:signature];
}

+ (IOSByteArray *)rsaEncryptWithByteArray:(IOSByteArray *)key
                            withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) rsaEncryptWithByteArray:key withByteArray:data];
}

+ (IOSByteArray *)aesEncryptWithJavaxCryptoSecretKey:(id<JavaxCryptoSecretKey>)key
                                       withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) aesEncryptWithJavaxCryptoSecretKey:key withByteArray:data];
}

+ (id<JavaxCryptoSecretKey>)generateAes128Key {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) generateAes128Key];
}

+ (id<JavaxCryptoSecretKey>)generateAes192Key {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) generateAes192Key];
}

+ (id<JavaxCryptoSecretKey>)generateAes256Key {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) generateAes256Key];
}

+ (IOSByteArray *)hmacSha256WithJavaxCryptoSecretKey:(id<JavaxCryptoSecretKey>)key
                                       withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) hmacSha256WithJavaxCryptoSecretKey:key withByteArray:data];
}

+ (JavaSecurityKeyPair *)generateKeyPairWithComKloudtekUtilCryptoAsymmetricAlgorithmEnum:(ComKloudtekUtilCryptoAsymmetricAlgorithmEnum *)alg
                                                                                 withInt:(int)keysize {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) generateKeyPairWithComKloudtekUtilCryptoAsymmetricAlgorithmEnum:alg withInt:keysize];
}

+ (IOSByteArray *)decryptWithJavaSecurityKey:(id<JavaSecurityKey>)key
                               withByteArray:(IOSByteArray *)data
                                withNSString:(NSString *)alg {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) decryptWithJavaSecurityKey:key withByteArray:data withNSString:alg];
}

+ (id<JavaxCryptoSecretKey>)generateAesKeyWithInt:(int)keysize {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) generateAesKeyWithInt:keysize];
}

+ (IOSByteArray *)rsaDecryptWithByteArray:(IOSByteArray *)key
                            withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) rsaDecryptWithByteArray:key withByteArray:data];
}

+ (void)verifySignatureWithNSString:(NSString *)algorithm
          withJavaSecurityPublicKey:(id<JavaSecurityPublicKey>)key
                      withByteArray:(IOSByteArray *)data
                      withByteArray:(IOSByteArray *)signature {
  [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) verifySignatureWithNSString:algorithm withJavaSecurityPublicKey:key withByteArray:data withByteArray:signature];
}

+ (IOSByteArray *)aesEncryptWithByteArray:(IOSByteArray *)key
                            withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) aesEncryptWithByteArray:key withByteArray:data];
}

+ (IOSByteArray *)aesDecryptWithByteArray:(IOSByteArray *)key
                            withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) aesDecryptWithByteArray:key withByteArray:data];
}

+ (IOSByteArray *)hmacSha512WithJavaxCryptoSecretKey:(id<JavaxCryptoSecretKey>)key
                                       withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) hmacSha512WithJavaxCryptoSecretKey:key withByteArray:data];
}

+ (IOSByteArray *)encryptWithJavaSecurityKey:(id<JavaSecurityKey>)key
                               withByteArray:(IOSByteArray *)data
                                withNSString:(NSString *)alg {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) encryptWithJavaSecurityKey:key withByteArray:data withNSString:alg];
}

+ (IOSByteArray *)cryptWithJavaSecurityKey:(id<JavaSecurityKey>)key
                             withByteArray:(IOSByteArray *)data
                              withNSString:(NSString *)alg
                                   withInt:(int)mode {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) cryptWithJavaSecurityKey:key withByteArray:data withNSString:alg withInt:mode];
}

+ (IOSByteArray *)hmacWithComKloudtekUtilCryptoDigestAlgorithmEnum:(ComKloudtekUtilCryptoDigestAlgorithmEnum *)algorithm
                                          withJavaxCryptoSecretKey:(id<JavaxCryptoSecretKey>)key
                                                     withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) hmacWithComKloudtekUtilCryptoDigestAlgorithmEnum:algorithm withJavaxCryptoSecretKey:key withByteArray:data];
}

+ (IOSByteArray *)rsaDecryptWithJavaSecurityPrivateKey:(id<JavaSecurityPrivateKey>)key
                                         withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) rsaDecryptWithJavaSecurityPrivateKey:key withByteArray:data];
}

+ (IOSByteArray *)rsaSignWithComKloudtekUtilCryptoDigestAlgorithmEnum:(ComKloudtekUtilCryptoDigestAlgorithmEnum *)digestAlgorithms
                                           withJavaSecurityPrivateKey:(id<JavaSecurityPrivateKey>)key
                                                        withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) rsaSignWithComKloudtekUtilCryptoDigestAlgorithmEnum:digestAlgorithms withJavaSecurityPrivateKey:key withByteArray:data];
}

+ (IOSByteArray *)hmacSha1WithJavaxCryptoSecretKey:(id<JavaxCryptoSecretKey>)key
                                     withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) hmacSha1WithJavaxCryptoSecretKey:key withByteArray:data];
}

+ (IOSByteArray *)signWithNSString:(NSString *)algorithm
        withJavaSecurityPrivateKey:(id<JavaSecurityPrivateKey>)key
                     withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) signWithNSString:algorithm withJavaSecurityPrivateKey:key withByteArray:data];
}

+ (IOSByteArray *)hmacWithJavaxCryptoSecretKey:(id<JavaxCryptoSecretKey>)key
  withComKloudtekUtilCryptoDigestAlgorithmEnum:(ComKloudtekUtilCryptoDigestAlgorithmEnum *)algorithms
                                 withByteArray:(IOSByteArray *)data {
  return [((ComKloudtekUtilCryptoCryptoEngine *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_provider_)) hmacWithComKloudtekUtilCryptoDigestAlgorithmEnum:algorithms withJavaxCryptoSecretKey:key withByteArray:data];
}

+ (IOSObjectArray *)splitKeyWithByteArray:(IOSByteArray *)key
                                  withInt:(int)amount {
  int keyLen = (int) [((IOSByteArray *) nil_chk(key)) count];
  JavaUtilArrayList *keys = [[JavaUtilArrayList alloc] initWithInt:amount];
  if (amount < 0) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Amount must be 1 or more"];
  }
  else if (amount == 1) {
    [keys addWithId:key];
  }
  else {
    JavaSecuritySecureRandom *rng = [[JavaSecuritySecureRandom alloc] init];
    IOSByteArray *xorVal = key;
    for (int i = 0; i < amount - 1; i++) {
      IOSByteArray *newKey = [IOSByteArray arrayWithLength:keyLen];
      [rng nextBytesWithByteArray:newKey];
      [keys addWithId:newKey];
      xorVal = [ComKloudtekUtilCryptoCryptoUtils xor__WithByteArray:xorVal withByteArray:newKey];
    }
    [keys addWithId:xorVal];
  }
  return [keys toArrayWithNSObjectArray:[IOSByteArray arrayWithDimensions:2 lengths:(int[]){ (int) [key count], amount }]];
}

+ (void)zeroWithCharArray2:(IOSObjectArray *)data {
  {
    IOSObjectArray *a__ = data;
    IOSCharArray * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    IOSCharArray * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      IOSCharArray *chars = (*b__++);
      if (chars != nil) {
        [JavaUtilArrays fillWithCharArray:chars withChar:0x0000];
      }
    }
  }
}

+ (void)zeroWithByteArray2:(IOSObjectArray *)data {
  {
    IOSObjectArray *a__ = data;
    IOSByteArray * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    IOSByteArray * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      IOSByteArray *bytes = (*b__++);
      if (bytes != nil) {
        [JavaUtilArrays fillWithByteArray:bytes withByte:(char) 0];
      }
    }
  }
}

+ (void)zeroWithJavaNioCharBuffer:(JavaNioCharBuffer *)data {
  [ComKloudtekUtilCryptoCryptoUtils zeroWithCharArray2:[IOSObjectArray arrayWithObjects:(id[]){ [((JavaNioCharBuffer *) nil_chk(data)) array] } count:1 type:[IOSCharArray iosClass]]];
}

+ (void)zeroWithJavaNioByteBuffer:(JavaNioByteBuffer *)data {
  [ComKloudtekUtilCryptoCryptoUtils zeroWithByteArray2:[IOSObjectArray arrayWithObjects:(id[]){ [((JavaNioByteBuffer *) nil_chk(data)) array] } count:1 type:[IOSByteArray iosClass]]];
}

+ (IOSByteArray *)mergeSplitKeyWithByteArray2:(IOSObjectArray *)keys {
  if (keys == nil) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"There must be at least one key"];
  }
  else {
    return [ComKloudtekUtilCryptoCryptoUtils mergeSplitKeyWithJavaUtilCollection:[JavaUtilArrays asListWithNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ keys } count:1 type:[IOSClass classWithClass:[NSObject class]]]]];
  }
}

+ (IOSByteArray *)mergeSplitKeyWithJavaUtilCollection:(id<JavaUtilCollection>)keys {
  if (keys == nil || [keys isEmpty]) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"There must be at least one key"];
  }
  else if ([keys size] == 1) {
    return [((id<JavaUtilIterator>) nil_chk([keys iterator])) next];
  }
  else {
    id<JavaUtilIterator> i = [keys iterator];
    IOSByteArray *val = [((id<JavaUtilIterator>) nil_chk(i)) next];
    int len = (int) [((IOSByteArray *) nil_chk(val)) count];
    while ([i hasNext]) {
      IOSByteArray *next = [i next];
      if ((int) [((IOSByteArray *) nil_chk(next)) count] != len) {
        @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"All keys must have the same length"];
      }
      val = [ComKloudtekUtilCryptoCryptoUtils xor__WithByteArray:val withByteArray:next];
    }
    return val;
  }
}

+ (IOSByteArray *)xor__WithByteArray:(IOSByteArray *)b1
                       withByteArray:(IOSByteArray *)b2 {
  IOSByteArray *val = [IOSByteArray arrayWithLength:(int) [((IOSByteArray *) nil_chk(b1)) count]];
  for (int i = 0; i < (int) [b1 count]; i++) {
    (*IOSByteArray_GetRef(val, i)) = (char) (IOSByteArray_Get(b1, i) ^ IOSByteArray_Get(nil_chk(b2), i));
  }
  return val;
}

+ (JavaSecuritySecureRandom *)rng {
  return ComKloudtekUtilCryptoCryptoUtils_rng__;
}

+ (void)destroyWithJavaSecurityKey:(id<JavaSecurityKey>)key {
  if (key != nil && [(id) key conformsToProtocol: @protocol(JavaxSecurityAuthDestroyable)]) {
    if (![((id<JavaxSecurityAuthDestroyable>) check_protocol_cast(key, @protocol(JavaxSecurityAuthDestroyable))) isDestroyed]) {
      @try {
        [((id<JavaxSecurityAuthDestroyable>) check_protocol_cast(key, @protocol(JavaxSecurityAuthDestroyable))) destroy];
      }
      @catch (JavaxSecurityAuthDestroyFailedException *e) {
        [((JavaUtilLoggingLogger *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_logger_)) logWithJavaUtilLoggingLevel:JavaUtilLoggingLevel_get_WARNING_() withNSString:[NSString stringWithFormat:@"Failed to destroy key: %@", [((JavaxSecurityAuthDestroyFailedException *) nil_chk(e)) getMessage]] withJavaLangThrowable:e];
      }
    }
  }
}

+ (IOSCharArray *)generateRandomPasswordWithInt:(int)len
                                    withBoolean:(BOOL)allCaps {
  IOSCharArray *charSet = allCaps ? ComKloudtekUtilCryptoCryptoUtils_symbolsAllCaps_ : ComKloudtekUtilCryptoCryptoUtils_symbols_;
  IOSCharArray *pw = [IOSCharArray arrayWithLength:len];
  for (int i = 0; i < len; i++) {
    (*IOSCharArray_GetRef(pw, i)) = IOSCharArray_Get(charSet, [((JavaSecuritySecureRandom *) nil_chk(ComKloudtekUtilCryptoCryptoUtils_rng__)) nextIntWithInt:(int) [charSet count]]);
  }
  return pw;
}

- (id)init {
  return [super init];
}

+ (void)initialize {
  if (self == [ComKloudtekUtilCryptoCryptoUtils class]) {
    {
      JavaLangStringBuilder *tmp = [[JavaLangStringBuilder alloc] init];
      for (unichar c = '2'; c <= '9'; c++) {
        (void) [tmp appendWithChar:c];
      }
      for (unichar c = 'A'; c <= 'Z'; c++) {
        if (c != 'I' && c != 'O') {
          (void) [tmp appendWithChar:c];
        }
      }
      ComKloudtekUtilCryptoCryptoUtils_symbolsAllCaps_ = [((NSString *) nil_chk([tmp description])) toCharArray];
      for (unichar c = 'a'; c <= 'z'; c++) {
        if (c != 'l' && c != 'o') {
          (void) [tmp appendWithChar:c];
        }
      }
      ComKloudtekUtilCryptoCryptoUtils_symbols_ = [((NSString *) nil_chk([tmp description])) toCharArray];
    }
    ComKloudtekUtilCryptoCryptoUtils_logger_ = [JavaUtilLoggingLogger getLoggerWithNSString:[[IOSClass classWithClass:[ComKloudtekUtilCryptoCryptoUtils class]] getName]];
    ComKloudtekUtilCryptoCryptoUtils_provider_ = [[ComKloudtekIdvkeyClientCryptoTestCryptoEngine alloc] init];
    ComKloudtekUtilCryptoCryptoUtils_rng__ = [[JavaSecuritySecureRandom alloc] init];
    ComKloudtekUtilCryptoCryptoUtils_initialized = YES;
  }
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "generateKeyWithComKloudtekUtilCryptoSymmetricAlgorithmEnum:withInt:", "generateKey", "Ljavax.crypto.SecretKey;", 0x9, NULL },
    { "generateRSA4096KeyPair", NULL, "Ljava.security.KeyPair;", 0x9, NULL },
    { "generateRSA2048KeyPair", NULL, "Ljava.security.KeyPair;", 0x9, NULL },
    { "generateHmacKeyWithComKloudtekUtilCryptoDigestAlgorithmEnum:", "generateHmacKey", "Ljavax.crypto.SecretKey;", 0x9, NULL },
    { "generatePBEAESKeyWithCharArray:withInt:withByteArray:withInt:", "generatePBEAESKey", "Ljavax.crypto.SecretKey;", 0x9, "Ljava.security.spec.InvalidKeySpecException;" },
    { "readRSAPublicKeyWithByteArray:", "readRSAPublicKey", "Ljava.security.interfaces.RSAPublicKey;", 0x9, "Ljava.security.spec.InvalidKeySpecException;" },
    { "readRSAPrivateKeyWithByteArray:", "readRSAPrivateKey", "Ljava.security.PrivateKey;", 0x9, "Ljava.security.spec.InvalidKeySpecException;" },
    { "readAESKeyWithByteArray:", "readAESKey", "Ljavax.crypto.SecretKey;", 0x9, NULL },
    { "readHMACKeyWithComKloudtekUtilCryptoDigestAlgorithmEnum:withByteArray:", "readHMACKey", "Ljavax.crypto.SecretKey;", 0x9, NULL },
    { "aesDecryptWithJavaxCryptoSecretKey:withByteArray:", "aesDecrypt", "[B", 0x9, "Ljava.security.InvalidKeyException;Ljavax.crypto.BadPaddingException;Ljavax.crypto.IllegalBlockSizeException;" },
    { "rsaEncryptWithJavaSecurityPublicKey:withByteArray:", "rsaEncrypt", "[B", 0x9, "Ljava.security.InvalidKeyException;Ljavax.crypto.BadPaddingException;Ljavax.crypto.IllegalBlockSizeException;" },
    { "rsaVerifySignatureWithComKloudtekUtilCryptoDigestAlgorithmEnum:withJavaSecurityPublicKey:withByteArray:withByteArray:", "rsaVerifySignature", "V", 0x9, "Ljava.security.InvalidKeyException;Ljava.security.SignatureException;" },
    { "rsaEncryptWithByteArray:withByteArray:", "rsaEncrypt", "[B", 0x9, "Ljava.security.InvalidKeyException;Ljavax.crypto.BadPaddingException;Ljavax.crypto.IllegalBlockSizeException;Ljava.security.spec.InvalidKeySpecException;" },
    { "aesEncryptWithJavaxCryptoSecretKey:withByteArray:", "aesEncrypt", "[B", 0x9, "Ljava.security.InvalidKeyException;Ljavax.crypto.BadPaddingException;Ljavax.crypto.IllegalBlockSizeException;" },
    { "generateAes128Key", NULL, "Ljavax.crypto.SecretKey;", 0x9, NULL },
    { "generateAes192Key", NULL, "Ljavax.crypto.SecretKey;", 0x9, NULL },
    { "generateAes256Key", NULL, "Ljavax.crypto.SecretKey;", 0x9, NULL },
    { "hmacSha256WithJavaxCryptoSecretKey:withByteArray:", "hmacSha256", "[B", 0x9, "Ljava.security.InvalidKeyException;" },
    { "generateKeyPairWithComKloudtekUtilCryptoAsymmetricAlgorithmEnum:withInt:", "generateKeyPair", "Ljava.security.KeyPair;", 0x9, NULL },
    { "decryptWithJavaSecurityKey:withByteArray:withNSString:", "decrypt", "[B", 0x9, "Ljava.security.InvalidKeyException;Ljavax.crypto.IllegalBlockSizeException;Ljavax.crypto.BadPaddingException;" },
    { "generateAesKeyWithInt:", "generateAesKey", "Ljavax.crypto.SecretKey;", 0x9, NULL },
    { "rsaDecryptWithByteArray:withByteArray:", "rsaDecrypt", "[B", 0x9, "Ljava.security.InvalidKeyException;Ljavax.crypto.BadPaddingException;Ljavax.crypto.IllegalBlockSizeException;Ljava.security.spec.InvalidKeySpecException;" },
    { "verifySignatureWithNSString:withJavaSecurityPublicKey:withByteArray:withByteArray:", "verifySignature", "V", 0x9, "Ljava.security.SignatureException;Ljava.security.InvalidKeyException;" },
    { "aesEncryptWithByteArray:withByteArray:", "aesEncrypt", "[B", 0x9, "Ljava.security.InvalidKeyException;Ljavax.crypto.BadPaddingException;Ljavax.crypto.IllegalBlockSizeException;" },
    { "aesDecryptWithByteArray:withByteArray:", "aesDecrypt", "[B", 0x9, "Ljava.security.InvalidKeyException;Ljavax.crypto.BadPaddingException;Ljavax.crypto.IllegalBlockSizeException;" },
    { "hmacSha512WithJavaxCryptoSecretKey:withByteArray:", "hmacSha512", "[B", 0x9, "Ljava.security.InvalidKeyException;" },
    { "encryptWithJavaSecurityKey:withByteArray:withNSString:", "encrypt", "[B", 0x9, "Ljava.security.InvalidKeyException;Ljavax.crypto.IllegalBlockSizeException;Ljavax.crypto.BadPaddingException;" },
    { "cryptWithJavaSecurityKey:withByteArray:withNSString:withInt:", "crypt", "[B", 0x9, "Ljava.security.InvalidKeyException;Ljavax.crypto.IllegalBlockSizeException;Ljavax.crypto.BadPaddingException;" },
    { "hmacWithComKloudtekUtilCryptoDigestAlgorithmEnum:withJavaxCryptoSecretKey:withByteArray:", "hmac", "[B", 0x9, "Ljava.security.InvalidKeyException;" },
    { "rsaDecryptWithJavaSecurityPrivateKey:withByteArray:", "rsaDecrypt", "[B", 0x9, "Ljava.security.InvalidKeyException;Ljavax.crypto.BadPaddingException;Ljavax.crypto.IllegalBlockSizeException;" },
    { "rsaSignWithComKloudtekUtilCryptoDigestAlgorithmEnum:withJavaSecurityPrivateKey:withByteArray:", "rsaSign", "[B", 0x9, "Ljava.security.InvalidKeyException;Ljava.security.SignatureException;" },
    { "hmacSha1WithJavaxCryptoSecretKey:withByteArray:", "hmacSha1", "[B", 0x9, "Ljava.security.InvalidKeyException;" },
    { "signWithNSString:withJavaSecurityPrivateKey:withByteArray:", "sign", "[B", 0x9, "Ljava.security.SignatureException;Ljava.security.InvalidKeyException;" },
    { "hmacWithJavaxCryptoSecretKey:withComKloudtekUtilCryptoDigestAlgorithmEnum:withByteArray:", "hmac", "[B", 0x9, "Ljava.security.InvalidKeyException;" },
    { "splitKeyWithByteArray:withInt:", "splitKey", "[[B", 0x9, NULL },
    { "zeroWithCharArray2:", "zero", "V", 0x89, NULL },
    { "zeroWithByteArray2:", "zero", "V", 0x89, NULL },
    { "zeroWithJavaNioCharBuffer:", "zero", "V", 0x9, NULL },
    { "zeroWithJavaNioByteBuffer:", "zero", "V", 0x9, NULL },
    { "mergeSplitKeyWithByteArray2:", "mergeSplitKey", "[B", 0x89, NULL },
    { "mergeSplitKeyWithJavaUtilCollection:", "mergeSplitKey", "[B", 0x9, NULL },
    { "xor__WithByteArray:withByteArray:", "xor", "[B", 0xa, NULL },
    { "rng", NULL, "Ljava.security.SecureRandom;", 0x9, NULL },
    { "destroyWithJavaSecurityKey:", "destroy", "V", 0x9, NULL },
    { "generateRandomPasswordWithInt:withBoolean:", "generateRandomPassword", "[C", 0x9, NULL },
    { "init", NULL, NULL, 0x1, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "symbolsAllCaps_", NULL, 0x1a, "[C", &ComKloudtekUtilCryptoCryptoUtils_symbolsAllCaps_,  },
    { "symbols_", NULL, 0x1a, "[C", &ComKloudtekUtilCryptoCryptoUtils_symbols_,  },
    { "logger_", NULL, 0x1a, "Ljava.util.logging.Logger;", &ComKloudtekUtilCryptoCryptoUtils_logger_,  },
    { "provider_", NULL, 0xa, "Lcom.kloudtek.kryptotek.CryptoEngine;", &ComKloudtekUtilCryptoCryptoUtils_provider_,  },
    { "rng__", "rng", 0x1a, "Ljava.security.SecureRandom;", &ComKloudtekUtilCryptoCryptoUtils_rng__,  },
  };
  static J2ObjcClassInfo _ComKloudtekUtilCryptoCryptoUtils = { "CryptoUtils", "com.kloudtek.kryptotek", NULL, 0x1, 46, methods, 5, fields, 0, NULL};
  return &_ComKloudtekUtilCryptoCryptoUtils;
}

@end
