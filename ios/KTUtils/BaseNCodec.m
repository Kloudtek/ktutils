//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: _java/com/kloudtek/util/BaseNCodec.java
//
//  Created by yinkaf on 6/11/14.
//

#include "BaseNCodec.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "StringUtils.h"
#include "java/lang/Boolean.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/util/Arrays.h"

@implementation KTUtilBaseNCodec

- (id)initWithInt:(int)unencodedBlockSize
          withInt:(int)encodedBlockSize
          withInt:(int)lineLength
          withInt:(int)chunkSeparatorLength {
  if (self = [super init]) {
    PAD_ = KTUtilBaseNCodec_PAD_DEFAULT;
    self->unencodedBlockSize_ = unencodedBlockSize;
    self->encodedBlockSize_ = encodedBlockSize;
    BOOL useChunking = lineLength > 0 && chunkSeparatorLength > 0;
    self->lineLength_ = useChunking ? (lineLength / encodedBlockSize) * encodedBlockSize : 0;
    self->chunkSeparatorLength_ = chunkSeparatorLength;
  }
  return self;
}

- (BOOL)hasDataWithKTUtilBaseNCodec_Context:(KTUtilBaseNCodec_Context *)context {
  return ((KTUtilBaseNCodec_Context *) nil_chk(context))->buffer_ != nil;
}

- (int)availableWithKTUtilBaseNCodec_Context:(KTUtilBaseNCodec_Context *)context {
  return ((KTUtilBaseNCodec_Context *) nil_chk(context))->buffer_ != nil ? context->pos_ - context->readPos_ : 0;
}

- (int)getDefaultBufferSize {
  return KTUtilBaseNCodec_DEFAULT_BUFFER_SIZE;
}

- (IOSByteArray *)resizeBufferWithKTUtilBaseNCodec_Context:(KTUtilBaseNCodec_Context *)context {
  if (((KTUtilBaseNCodec_Context *) nil_chk(context))->buffer_ == nil) {
    context->buffer_ = [IOSByteArray arrayWithLength:[self getDefaultBufferSize]];
    context->pos_ = 0;
    context->readPos_ = 0;
  }
  else {
    IOSByteArray *b = [IOSByteArray arrayWithLength:(int) [context->buffer_ count] * KTUtilBaseNCodec_DEFAULT_BUFFER_RESIZE_FACTOR];
    [JavaLangSystem arraycopyWithId:context->buffer_ withInt:0 withId:b withInt:0 withInt:(int) [context->buffer_ count]];
    context->buffer_ = b;
  }
  return context->buffer_;
}

- (IOSByteArray *)ensureBufferSizeWithInt:(int)size
             withKTUtilBaseNCodec_Context:(KTUtilBaseNCodec_Context *)context {
  if ((((KTUtilBaseNCodec_Context *) nil_chk(context))->buffer_ == nil) || ((int) [context->buffer_ count] < context->pos_ + size)) {
    return [self resizeBufferWithKTUtilBaseNCodec_Context:context];
  }
  return context->buffer_;
}

- (int)readResultsWithByteArray:(IOSByteArray *)b
                        withInt:(int)bPos
                        withInt:(int)bAvail
   withKTUtilBaseNCodec_Context:(KTUtilBaseNCodec_Context *)context {
  if (((KTUtilBaseNCodec_Context *) nil_chk(context))->buffer_ != nil) {
    int len = [JavaLangMath minWithInt:[self availableWithKTUtilBaseNCodec_Context:context] withInt:bAvail];
    [JavaLangSystem arraycopyWithId:context->buffer_ withInt:context->readPos_ withId:b withInt:bPos withInt:len];
    context->readPos_ += len;
    if (context->readPos_ >= context->pos_) {
      context->buffer_ = nil;
    }
    return len;
  }
  return context->eof_ ? KTUtilBaseNCodec_EOF : 0;
}

+ (BOOL)isWhiteSpaceWithByte:(char)byteToCheck {
  switch (byteToCheck) {
    case ' ':
    case 0x000a:
    case 0x000d:
    case 0x0009:
    return YES;
    default:
    return NO;
  }
}

- (id)encodeWithId:(id)obj {
  if (!([obj isKindOfClass:[IOSByteArray class]])) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Parameter supplied to Base-N encode is not a byte[]"];
  }
  return [self encodeWithByteArray:(IOSByteArray *) check_class_cast(obj, [IOSByteArray class])];
}

- (NSString *)encodeToStringWithByteArray:(IOSByteArray *)pArray {
  return [KTUtilStringUtils utf8WithByteArray:[self encodeWithByteArray:pArray]];
}

- (NSString *)encodeAsStringWithByteArray:(IOSByteArray *)pArray {
  return [KTUtilStringUtils utf8WithByteArray:[self encodeWithByteArray:pArray]];
}

- (id)decodeWithId:(id)obj {
  if ([obj isKindOfClass:[IOSByteArray class]]) {
    return [self decodeWithByteArray:(IOSByteArray *) check_class_cast(obj, [IOSByteArray class])];
  }
  else if ([obj isKindOfClass:[NSString class]]) {
    return [self decodeWithNSString:(NSString *) check_class_cast(obj, [NSString class])];
  }
  else {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Parameter supplied to Base-N decode is not a byte[] or a String"];
  }
}

- (IOSByteArray *)decodeWithNSString:(NSString *)pArray {
  return [self decodeWithByteArray:[KTUtilStringUtils utf8WithNSString:pArray]];
}

- (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)pArray {
  if (pArray == nil || (int) [pArray count] == 0) {
    return pArray;
  }
  KTUtilBaseNCodec_Context *context = [[KTUtilBaseNCodec_Context alloc] init];
  [self decodeWithByteArray:pArray withInt:0 withInt:(int) [((IOSByteArray *) nil_chk(pArray)) count] withKTUtilBaseNCodec_Context:context];
  [self decodeWithByteArray:pArray withInt:0 withInt:KTUtilBaseNCodec_EOF withKTUtilBaseNCodec_Context:context];
  IOSByteArray *result = [IOSByteArray arrayWithLength:context->pos_];
  [self readResultsWithByteArray:result withInt:0 withInt:(int) [result count] withKTUtilBaseNCodec_Context:context];
  return result;
}

- (IOSByteArray *)encodeWithByteArray:(IOSByteArray *)pArray {
  if (pArray == nil || (int) [pArray count] == 0) {
    return pArray;
  }
  KTUtilBaseNCodec_Context *context = [[KTUtilBaseNCodec_Context alloc] init];
  [self encodeWithByteArray:pArray withInt:0 withInt:(int) [((IOSByteArray *) nil_chk(pArray)) count] withKTUtilBaseNCodec_Context:context];
  [self encodeWithByteArray:pArray withInt:0 withInt:KTUtilBaseNCodec_EOF withKTUtilBaseNCodec_Context:context];
  IOSByteArray *buf = [IOSByteArray arrayWithLength:context->pos_ - context->readPos_];
  [self readResultsWithByteArray:buf withInt:0 withInt:(int) [buf count] withKTUtilBaseNCodec_Context:context];
  return buf;
}

- (void)encodeWithByteArray:(IOSByteArray *)pArray
                    withInt:(int)i
                    withInt:(int)length
withKTUtilBaseNCodec_Context:(KTUtilBaseNCodec_Context *)context {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)decodeWithByteArray:(IOSByteArray *)pArray
                    withInt:(int)i
                    withInt:(int)length
withKTUtilBaseNCodec_Context:(KTUtilBaseNCodec_Context *)context {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (BOOL)isInAlphabetWithByte:(char)value {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (BOOL)isInAlphabetWithByteArray:(IOSByteArray *)arrayOctet
                      withBoolean:(BOOL)allowWSPad {
  for (int i = 0; i < (int) [((IOSByteArray *) nil_chk(arrayOctet)) count]; i++) {
    if (![self isInAlphabetWithByte:IOSByteArray_Get(arrayOctet, i)] && (!allowWSPad || ((IOSByteArray_Get(arrayOctet, i) != PAD_) && ![KTUtilBaseNCodec isWhiteSpaceWithByte:IOSByteArray_Get(arrayOctet, i)]))) {
      return NO;
    }
  }
  return YES;
}

- (BOOL)isInAlphabetWithNSString:(NSString *)basen {
  return [self isInAlphabetWithByteArray:[KTUtilStringUtils utf8WithNSString:basen] withBoolean:YES];
}

- (BOOL)containsAlphabetOrPadWithByteArray:(IOSByteArray *)arrayOctet {
  if (arrayOctet == nil) {
    return NO;
  }
  {
    IOSByteArray *a__ = arrayOctet;
    char const *b__ = ((IOSByteArray *) nil_chk(a__))->buffer_;
    char const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      char element = (*b__++);
      if (PAD_ == element || [self isInAlphabetWithByte:element]) {
        return YES;
      }
    }
  }
  return NO;
}

- (long long int)getEncodedLengthWithByteArray:(IOSByteArray *)pArray {
  long long int len = (((int) [((IOSByteArray *) nil_chk(pArray)) count] + unencodedBlockSize_ - 1) / unencodedBlockSize_) * (long long int) encodedBlockSize_;
  if (lineLength_ > 0) {
    len += ((len + lineLength_ - 1) / lineLength_) * chunkSeparatorLength_;
  }
  return len;
}

- (void)copyAllFieldsTo:(KTUtilBaseNCodec *)other {
  [super copyAllFieldsTo:other];
  other->PAD_ = PAD_;
  other->chunkSeparatorLength_ = chunkSeparatorLength_;
  other->encodedBlockSize_ = encodedBlockSize_;
  other->lineLength_ = lineLength_;
  other->unencodedBlockSize_ = unencodedBlockSize_;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "initWithInt:withInt:withInt:withInt:", "BaseNCodec", NULL, 0x4, NULL },
    { "hasDataWithKTUtilBaseNCodec_Context:", "hasData", "Z", 0x0, NULL },
    { "availableWithKTUtilBaseNCodec_Context:", "available", "I", 0x0, NULL },
    { "getDefaultBufferSize", NULL, "I", 0x4, NULL },
    { "resizeBufferWithKTUtilBaseNCodec_Context:", "resizeBuffer", "[B", 0x2, NULL },
    { "ensureBufferSizeWithInt:withKTUtilBaseNCodec_Context:", "ensureBufferSize", "[B", 0x4, NULL },
    { "readResultsWithByteArray:withInt:withInt:withKTUtilBaseNCodec_Context:", "readResults", "I", 0x0, NULL },
    { "isWhiteSpaceWithByte:", "isWhiteSpace", "Z", 0xc, NULL },
    { "encodeWithId:", "encode", "Ljava.lang.Object;", 0x1, "Ljava.lang.IllegalArgumentException;" },
    { "encodeToStringWithByteArray:", "encodeToString", "Ljava.lang.String;", 0x1, NULL },
    { "encodeAsStringWithByteArray:", "encodeAsString", "Ljava.lang.String;", 0x1, NULL },
    { "decodeWithId:", "decode", "Ljava.lang.Object;", 0x1, "Ljava.lang.IllegalArgumentException;" },
    { "decodeWithNSString:", "decode", "[B", 0x1, NULL },
    { "decodeWithByteArray:", "decode", "[B", 0x1, NULL },
    { "encodeWithByteArray:", "encode", "[B", 0x1, NULL },
    { "encodeWithByteArray:withInt:withInt:withKTUtilBaseNCodec_Context:", "encode", "V", 0x400, NULL },
    { "decodeWithByteArray:withInt:withInt:withKTUtilBaseNCodec_Context:", "decode", "V", 0x400, NULL },
    { "isInAlphabetWithByte:", "isInAlphabet", "Z", 0x404, NULL },
    { "isInAlphabetWithByteArray:withBoolean:", "isInAlphabet", "Z", 0x1, NULL },
    { "isInAlphabetWithNSString:", "isInAlphabet", "Z", 0x1, NULL },
    { "containsAlphabetOrPadWithByteArray:", "containsAlphabetOrPad", "Z", 0x4, NULL },
    { "getEncodedLengthWithByteArray:", "getEncodedLength", "J", 0x1, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "EOF__", "EOF", 0x18, "I", NULL, .constantValue.asInt = KTUtilBaseNCodec_EOF },
    { "MIME_CHUNK_SIZE_", NULL, 0x19, "I", NULL, .constantValue.asInt = KTUtilBaseNCodec_MIME_CHUNK_SIZE },
    { "PEM_CHUNK_SIZE_", NULL, 0x19, "I", NULL, .constantValue.asInt = KTUtilBaseNCodec_PEM_CHUNK_SIZE },
    { "DEFAULT_BUFFER_RESIZE_FACTOR_", NULL, 0x1a, "I", NULL, .constantValue.asInt = KTUtilBaseNCodec_DEFAULT_BUFFER_RESIZE_FACTOR },
    { "DEFAULT_BUFFER_SIZE_", NULL, 0x1a, "I", NULL, .constantValue.asInt = KTUtilBaseNCodec_DEFAULT_BUFFER_SIZE },
    { "MASK_8BITS_", NULL, 0x1c, "I", NULL, .constantValue.asInt = KTUtilBaseNCodec_MASK_8BITS },
    { "PAD_DEFAULT_", NULL, 0x1c, "B", NULL, .constantValue.asChar = KTUtilBaseNCodec_PAD_DEFAULT },
    { "PAD_", NULL, 0x14, "B", NULL,  },
    { "unencodedBlockSize_", NULL, 0x12, "I", NULL,  },
    { "encodedBlockSize_", NULL, 0x12, "I", NULL,  },
    { "lineLength_", NULL, 0x14, "I", NULL,  },
    { "chunkSeparatorLength_", NULL, 0x12, "I", NULL,  },
  };
  static J2ObjcClassInfo _KTUtilBaseNCodec = { "BaseNCodec", "com.kloudtek.util", NULL, 0x401, 22, methods, 12, fields, 0, NULL};
  return &_KTUtilBaseNCodec;
}

@end

@implementation KTUtilBaseNCodec_Context

- (id)init {
  return [super init];
}

- (NSString *)description {
  return [NSString formatWithNSString:@"%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, modulus=%s, pos=%s, readPos=%s]" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [[self getClass] getSimpleName], [JavaUtilArrays toStringWithByteArray:buffer_], [JavaLangInteger valueOfWithInt:currentLinePos_], [JavaLangBoolean valueOfWithBoolean:eof_], [JavaLangInteger valueOfWithInt:ibitWorkArea_], [JavaLangLong valueOfWithLong:lbitWorkArea_], [JavaLangInteger valueOfWithInt:modulus_], [JavaLangInteger valueOfWithInt:pos_], [JavaLangInteger valueOfWithInt:readPos_] } count:9 type:[IOSClass classWithClass:[NSObject class]]]];
}

- (void)copyAllFieldsTo:(KTUtilBaseNCodec_Context *)other {
  [super copyAllFieldsTo:other];
  other->buffer_ = buffer_;
  other->currentLinePos_ = currentLinePos_;
  other->eof_ = eof_;
  other->ibitWorkArea_ = ibitWorkArea_;
  other->lbitWorkArea_ = lbitWorkArea_;
  other->modulus_ = modulus_;
  other->pos_ = pos_;
  other->readPos_ = readPos_;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "init", "Context", NULL, 0x0, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "ibitWorkArea_", NULL, 0x0, "I", NULL,  },
    { "lbitWorkArea_", NULL, 0x0, "J", NULL,  },
    { "buffer_", NULL, 0x0, "[B", NULL,  },
    { "pos_", NULL, 0x0, "I", NULL,  },
    { "readPos_", NULL, 0x0, "I", NULL,  },
    { "eof_", NULL, 0x0, "Z", NULL,  },
    { "currentLinePos_", NULL, 0x0, "I", NULL,  },
    { "modulus_", NULL, 0x0, "I", NULL,  },
  };
  static J2ObjcClassInfo _KTUtilBaseNCodec_Context = { "Context", "com.kloudtek.util", "BaseNCodec", 0x8, 2, methods, 8, fields, 0, NULL};
  return &_KTUtilBaseNCodec_Context;
}

@end
