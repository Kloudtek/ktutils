//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: com/kloudtek/util/BaseNCodec.java
//
//  Created by yannick on 06/01/14.
//

#include "BaseNCodec.h"
#include "IOSByteArray.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "StringUtils.h"
#include "java/lang/Boolean.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/util/Arrays.h"

@implementation KTUtilsBaseNCodec

+ (int)getEOF {
  return KTUtilsBaseNCodec_EOF;
}

+ (int)MIME_CHUNK_SIZE {
  return KTUtilsBaseNCodec_MIME_CHUNK_SIZE;
}

+ (int)PEM_CHUNK_SIZE {
  return KTUtilsBaseNCodec_PEM_CHUNK_SIZE;
}

+ (int)MASK_8BITS {
  return KTUtilsBaseNCodec_MASK_8BITS;
}

+ (char)PAD_DEFAULT {
  return KTUtilsBaseNCodec_PAD_DEFAULT;
}

- (id)initWithInt:(int)unencodedBlockSize
          withInt:(int)encodedBlockSize
          withInt:(int)lineLength
          withInt:(int)chunkSeparatorLength {
  if (self = [super init]) {
    PAD_ = KTUtilsBaseNCodec_PAD_DEFAULT;
    self->unencodedBlockSize_ = unencodedBlockSize;
    self->encodedBlockSize_ = encodedBlockSize;
    BOOL useChunking = lineLength > 0 && chunkSeparatorLength > 0;
    self->lineLength_ = useChunking ? (lineLength / encodedBlockSize) * encodedBlockSize : 0;
    self->chunkSeparatorLength_ = chunkSeparatorLength;
  }
  return self;
}

- (BOOL)hasDataWithKTUtilsBaseNCodec_Context:(KTUtilsBaseNCodec_Context *)context {
  return ((KTUtilsBaseNCodec_Context *) nil_chk(context))->buffer_ != nil;
}

- (int)availableWithKTUtilsBaseNCodec_Context:(KTUtilsBaseNCodec_Context *)context {
  return ((KTUtilsBaseNCodec_Context *) nil_chk(context))->buffer_ != nil ? context->pos_ - context->readPos_ : 0;
}

- (int)getDefaultBufferSize {
  return KTUtilsBaseNCodec_DEFAULT_BUFFER_SIZE;
}

- (IOSByteArray *)resizeBufferWithKTUtilsBaseNCodec_Context:(KTUtilsBaseNCodec_Context *)context {
  if (((KTUtilsBaseNCodec_Context *) nil_chk(context))->buffer_ == nil) {
    context->buffer_ = [IOSByteArray arrayWithLength:[self getDefaultBufferSize]];
    context->pos_ = 0;
    context->readPos_ = 0;
  }
  else {
    IOSByteArray *b = [IOSByteArray arrayWithLength:(int) [context->buffer_ count] * KTUtilsBaseNCodec_DEFAULT_BUFFER_RESIZE_FACTOR];
    [JavaLangSystem arraycopyWithId:context->buffer_ withInt:0 withId:b withInt:0 withInt:(int) [context->buffer_ count]];
    context->buffer_ = b;
  }
  return context->buffer_;
}

- (IOSByteArray *)ensureBufferSizeWithInt:(int)size
            withKTUtilsBaseNCodec_Context:(KTUtilsBaseNCodec_Context *)context {
  if ((((KTUtilsBaseNCodec_Context *) nil_chk(context))->buffer_ == nil) || ((int) [context->buffer_ count] < context->pos_ + size)) {
    return [self resizeBufferWithKTUtilsBaseNCodec_Context:context];
  }
  return context->buffer_;
}

- (int)readResultsWithByteArray:(IOSByteArray *)b
                        withInt:(int)bPos
                        withInt:(int)bAvail
  withKTUtilsBaseNCodec_Context:(KTUtilsBaseNCodec_Context *)context {
  if (((KTUtilsBaseNCodec_Context *) nil_chk(context))->buffer_ != nil) {
    int len = [JavaLangMath minWithInt:[self availableWithKTUtilsBaseNCodec_Context:context] withInt:bAvail];
    [JavaLangSystem arraycopyWithId:context->buffer_ withInt:context->readPos_ withId:b withInt:bPos withInt:len];
    context->readPos_ += len;
    if (context->readPos_ >= context->pos_) {
      context->buffer_ = nil;
    }
    return len;
  }
  return context->eof_ ? KTUtilsBaseNCodec_EOF : 0;
}

+ (BOOL)isWhiteSpaceWithByte:(char)byteToCheck {
  switch (byteToCheck) {
    case ' ':
    case 0x000a:
    case 0x000d:
    case 0x0009:
    return YES;
    default:
    return NO;
  }
}

- (id)encodeWithId:(id)obj {
  if (!([obj isKindOfClass:[IOSByteArray class]])) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Parameter supplied to Base-N encode is not a byte[]"];
  }
  return [self encodeWithByteArray:(IOSByteArray *) check_class_cast(obj, [IOSByteArray class])];
}

- (NSString *)encodeToStringWithByteArray:(IOSByteArray *)pArray {
  return [KTUtilsStringUtils fromUTF8WithByteArray:[self encodeWithByteArray:pArray]];
}

- (NSString *)encodeAsStringWithByteArray:(IOSByteArray *)pArray {
  return [KTUtilsStringUtils fromUTF8WithByteArray:[self encodeWithByteArray:pArray]];
}

- (id)decodeWithId:(id)obj {
  if ([obj isKindOfClass:[IOSByteArray class]]) {
    return [self decodeWithByteArray:(IOSByteArray *) check_class_cast(obj, [IOSByteArray class])];
  }
  else if ([obj isKindOfClass:[NSString class]]) {
    return [self decodeWithNSString:(NSString *) check_class_cast(obj, [NSString class])];
  }
  else {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Parameter supplied to Base-N decode is not a byte[] or a String"];
  }
}

- (IOSByteArray *)decodeWithNSString:(NSString *)pArray {
  return [self decodeWithByteArray:[KTUtilsStringUtils toUTF8WithNSString:pArray]];
}

- (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)pArray {
  if (pArray == nil || (int) [pArray count] == 0) {
    return pArray;
  }
  KTUtilsBaseNCodec_Context *context = [[KTUtilsBaseNCodec_Context alloc] init];
  [self decodeWithByteArray:pArray withInt:0 withInt:(int) [((IOSByteArray *) nil_chk(pArray)) count] withKTUtilsBaseNCodec_Context:context];
  [self decodeWithByteArray:pArray withInt:0 withInt:KTUtilsBaseNCodec_EOF withKTUtilsBaseNCodec_Context:context];
  IOSByteArray *result = [IOSByteArray arrayWithLength:context->pos_];
  [self readResultsWithByteArray:result withInt:0 withInt:(int) [result count] withKTUtilsBaseNCodec_Context:context];
  return result;
}

- (IOSByteArray *)encodeWithByteArray:(IOSByteArray *)pArray {
  if (pArray == nil || (int) [pArray count] == 0) {
    return pArray;
  }
  KTUtilsBaseNCodec_Context *context = [[KTUtilsBaseNCodec_Context alloc] init];
  [self encodeWithByteArray:pArray withInt:0 withInt:(int) [((IOSByteArray *) nil_chk(pArray)) count] withKTUtilsBaseNCodec_Context:context];
  [self encodeWithByteArray:pArray withInt:0 withInt:KTUtilsBaseNCodec_EOF withKTUtilsBaseNCodec_Context:context];
  IOSByteArray *buf = [IOSByteArray arrayWithLength:context->pos_ - context->readPos_];
  [self readResultsWithByteArray:buf withInt:0 withInt:(int) [buf count] withKTUtilsBaseNCodec_Context:context];
  return buf;
}

- (void)encodeWithByteArray:(IOSByteArray *)pArray
                    withInt:(int)i
                    withInt:(int)length
withKTUtilsBaseNCodec_Context:(KTUtilsBaseNCodec_Context *)context {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)decodeWithByteArray:(IOSByteArray *)pArray
                    withInt:(int)i
                    withInt:(int)length
withKTUtilsBaseNCodec_Context:(KTUtilsBaseNCodec_Context *)context {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (BOOL)isInAlphabetWithByte:(char)value {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (BOOL)isInAlphabetWithByteArray:(IOSByteArray *)arrayOctet
                      withBoolean:(BOOL)allowWSPad {
  for (int i = 0; i < (int) [((IOSByteArray *) nil_chk(arrayOctet)) count]; i++) {
    if (![self isInAlphabetWithByte:IOSByteArray_Get(arrayOctet, i)] && (!allowWSPad || ((IOSByteArray_Get(arrayOctet, i) != PAD_) && ![KTUtilsBaseNCodec isWhiteSpaceWithByte:IOSByteArray_Get(arrayOctet, i)]))) {
      return NO;
    }
  }
  return YES;
}

- (BOOL)isInAlphabetWithNSString:(NSString *)basen {
  return [self isInAlphabetWithByteArray:[KTUtilsStringUtils toUTF8WithNSString:basen] withBoolean:YES];
}

- (BOOL)containsAlphabetOrPadWithByteArray:(IOSByteArray *)arrayOctet {
  if (arrayOctet == nil) {
    return NO;
  }
  {
    IOSByteArray *a__ = arrayOctet;
    char const *b__ = ((IOSByteArray *) nil_chk(a__))->buffer_;
    char const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      char element = (*b__++);
      if (PAD_ == element || [self isInAlphabetWithByte:element]) {
        return YES;
      }
    }
  }
  return NO;
}

- (long long int)getEncodedLengthWithByteArray:(IOSByteArray *)pArray {
  long long int len = (((int) [((IOSByteArray *) nil_chk(pArray)) count] + unencodedBlockSize_ - 1) / unencodedBlockSize_) * (long long int) encodedBlockSize_;
  if (lineLength_ > 0) {
    len += ((len + lineLength_ - 1) / lineLength_) * chunkSeparatorLength_;
  }
  return len;
}

- (void)copyAllFieldsTo:(KTUtilsBaseNCodec *)other {
  [super copyAllFieldsTo:other];
  other->PAD_ = PAD_;
  other->chunkSeparatorLength_ = chunkSeparatorLength_;
  other->encodedBlockSize_ = encodedBlockSize_;
  other->lineLength_ = lineLength_;
  other->unencodedBlockSize_ = unencodedBlockSize_;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "initWithInt:withInt:withInt:withInt:", NULL, NULL, 0x4, NULL },
    { "hasDataWithKTUtilsBaseNCodec_Context:", NULL, "Z", 0x0, NULL },
    { "availableWithKTUtilsBaseNCodec_Context:", NULL, "I", 0x0, NULL },
    { "getDefaultBufferSize", NULL, "I", 0x4, NULL },
    { "resizeBufferWithKTUtilsBaseNCodec_Context:", NULL, "LIOSByteArray", 0x2, NULL },
    { "ensureBufferSizeWithInt:withKTUtilsBaseNCodec_Context:", NULL, "LIOSByteArray", 0x4, NULL },
    { "readResultsWithByteArray:withInt:withInt:withKTUtilsBaseNCodec_Context:", NULL, "I", 0x0, NULL },
    { "isWhiteSpaceWithByte:", NULL, "Z", 0xc, NULL },
    { "encodeWithId:", NULL, "LNSObject", 0x1, "JavaLangIllegalArgumentException" },
    { "encodeToStringWithByteArray:", NULL, "LNSString", 0x1, NULL },
    { "encodeAsStringWithByteArray:", NULL, "LNSString", 0x1, NULL },
    { "decodeWithId:", NULL, "LNSObject", 0x1, "JavaLangIllegalArgumentException" },
    { "decodeWithNSString:", NULL, "LIOSByteArray", 0x1, NULL },
    { "decodeWithByteArray:", NULL, "LIOSByteArray", 0x1, NULL },
    { "encodeWithByteArray:", NULL, "LIOSByteArray", 0x1, NULL },
    { "encodeWithByteArray:withInt:withInt:withKTUtilsBaseNCodec_Context:", NULL, "V", 0x400, NULL },
    { "decodeWithByteArray:withInt:withInt:withKTUtilsBaseNCodec_Context:", NULL, "V", 0x400, NULL },
    { "isInAlphabetWithByte:", NULL, "Z", 0x404, NULL },
    { "isInAlphabetWithByteArray:withBoolean:", NULL, "Z", 0x1, NULL },
    { "isInAlphabetWithNSString:", NULL, "Z", 0x1, NULL },
    { "containsAlphabetOrPadWithByteArray:", NULL, "Z", 0x4, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "EOF__", "EOF", 0x18, "I" },
    { "MIME_CHUNK_SIZE_", NULL, 0x19, "I" },
    { "PEM_CHUNK_SIZE_", NULL, 0x19, "I" },
    { "DEFAULT_BUFFER_RESIZE_FACTOR_", NULL, 0x1a, "I" },
    { "DEFAULT_BUFFER_SIZE_", NULL, 0x1a, "I" },
    { "MASK_8BITS_", NULL, 0x1c, "I" },
    { "PAD_DEFAULT_", NULL, 0x1c, "B" },
    { "PAD_", NULL, 0x14, "B" },
    { "unencodedBlockSize_", NULL, 0x12, "I" },
    { "encodedBlockSize_", NULL, 0x12, "I" },
    { "lineLength_", NULL, 0x14, "I" },
    { "chunkSeparatorLength_", NULL, 0x12, "I" },
  };
  static J2ObjcClassInfo _KTUtilsBaseNCodec = { "BaseNCodec", "com.kloudtek.util", NULL, 0x401, 21, methods, 12, fields, 0, NULL};
  return &_KTUtilsBaseNCodec;
}

@end
@implementation KTUtilsBaseNCodec_Context

- (id)init {
  return [super init];
}

- (NSString *)description {
  return [NSString formatWithNSString:@"%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, modulus=%s, pos=%s, readPos=%s]" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [[self getClass] getSimpleName], [JavaUtilArrays toStringWithByteArray:buffer_], [JavaLangInteger valueOfWithInt:currentLinePos_], [JavaLangBoolean valueOfWithBoolean:eof_], [JavaLangInteger valueOfWithInt:ibitWorkArea_], [JavaLangLong valueOfWithLong:lbitWorkArea_], [JavaLangInteger valueOfWithInt:modulus_], [JavaLangInteger valueOfWithInt:pos_], [JavaLangInteger valueOfWithInt:readPos_] } count:9 type:[IOSClass classWithClass:[NSObject class]]]];
}

- (void)copyAllFieldsTo:(KTUtilsBaseNCodec_Context *)other {
  [super copyAllFieldsTo:other];
  other->buffer_ = buffer_;
  other->currentLinePos_ = currentLinePos_;
  other->eof_ = eof_;
  other->ibitWorkArea_ = ibitWorkArea_;
  other->lbitWorkArea_ = lbitWorkArea_;
  other->modulus_ = modulus_;
  other->pos_ = pos_;
  other->readPos_ = readPos_;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "init", NULL, NULL, 0x0, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "ibitWorkArea_", NULL, 0x0, "I" },
    { "lbitWorkArea_", NULL, 0x0, "J" },
    { "buffer_", NULL, 0x0, "LIOSByteArray" },
    { "pos_", NULL, 0x0, "I" },
    { "readPos_", NULL, 0x0, "I" },
    { "eof_", NULL, 0x0, "Z" },
    { "currentLinePos_", NULL, 0x0, "I" },
    { "modulus_", NULL, 0x0, "I" },
  };
  static J2ObjcClassInfo _KTUtilsBaseNCodec_Context = { "Context", "com.kloudtek.util", "BaseNCodec", 0x8, 1, methods, 8, fields, 0, NULL};
  return &_KTUtilsBaseNCodec_Context;
}

@end
